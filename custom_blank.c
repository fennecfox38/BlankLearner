/************************************************************************************************************
???? ???: custom_blank.c
??? ???: void custom_blank(FILE *fp,unsigned int* pcnt,wdif** pword);
??? ???: 1. ?????? ????? ???? ???.  2. SPACE?? ???????? ??? ???¥è? ????. 
??? ???: fp?? ???? ??????, cnt?? word?? ???? cnt?? word?? ??????? ??????????.
? ¢® : blankgenerator?? screen?? ??? ??????. 
??????: ?????, ????? 
************************************************************************************************************/

#include"header.h"

enum {Out=0,In}; // ??????? ???? ??? ??????? ????? ?????. 

typedef struct{ // wdif?? ?•U?????? ?????????? ????? ?????? ??? ????? ??? ?? ????? ????? ????. 
	char str[LOW]; // ??? ???? 
	unsigned int len,loc; // ????? ????? ?????????? ???? ??? ??? 
	boolean bool_blank; // ????? ?? ? ???? 
	COORD Pos; // ????? ???? ???. 
}wordinfo;

void SetBlank(FILE* fp,unsigned int n,wordinfo* word); // ????? ??? ??©ª? ????. (??? ??? ??? ???.) 

void custom_blank(FILE *fp,unsigned int* pcnt,wdif** pword){
	unsigned int cnt,len,cnt_;
	char c; int i;
	boolean STATE=Out;
	
	wdif *word_=(wdif*)calloc(1,sizeof(wdif));
	wordinfo *word=(wordinfo*)calloc(1,sizeof(wordinfo));
	
	CLEAR puts("????? ???? ???. SPACE?? ????? ????????. ESC?? ???.");
	fseek(fp,0,SEEK_SET); 
	for(cnt=len=0;(c=fgetc(fp))!=EOF;){
		if(isalpha(c)){
			if(STATE==Out) { STATE=In; GetXY(word[cnt].Pos);}
			word[cnt].str[len++]=c;
		}
		else if(STATE==In){
			STATE=Out;
			word[cnt].str[len]='\0';
			word[cnt].len=len;
			word[cnt].loc=ftell(fp)-len-1;
			word=(wordinfo*)realloc(word,sizeof(wordinfo)*(++cnt+1));
			word[cnt].bool_blank=FALSE;
			len=0;
		}
		if (c==MARK) c='_';
		putc(c,stdout);
	}
	GotoXY(word[(i=0)].Pos);
	while((c=getch())!=ESC){
		switch (c){
			case LEFT: mvword(&i,-1,cnt); break;
			case RIGHT: mvword(&i,1,cnt); break;
			case TAB: mvword(&i,+10,cnt); break;
			case SPACE: SetBlank(fp,i,word); break;
		}
		GotoXY(word[i].Pos);
	}
	
	for(i=cnt_=0;i<cnt;++i){
		if(word[i].bool_blank){
			word_[cnt_].len=word[i].len;
			word_[cnt_].loc=word[i].loc;
			word_[cnt_].pos.X=word[i].Pos.X;
			word_[cnt_].pos.Y=word[i].Pos.Y;
			strcpy(word_[cnt_].str,word[i].str);
			word_[cnt_].wrongstr[0]=word_[cnt_].stat=0;
			word_=(wdif*)realloc(word_,sizeof(wdif)*(++cnt_+1));
		}
	}
	free(word);
	
	*pcnt=cnt_;
	*pword=word_;
	return;
}

void SetBlank(FILE* fp, unsigned int n,wordinfo* word){
	unsigned int i;
	fseek(fp,word[n].loc,SEEK_SET);
	GotoXY(word[n].Pos);
	if(word[n].bool_blank){					// ??? ???????? 
    	fputs(word[n].str,fp);
		fputs(word[n].str,stdout);			// ??? ??????? ?????????. 
	}
	else{									// ?? ??? ?????? 
		putc(MARK,fp); putc('_',stdout);
		for(i=word[n].len-1;i!=0;--i){
			putc('_',fp);
			putc('_',stdout);				// ????. 
		}
	}
	GotoXY(word[n].Pos);					// ??? ??? ????. 
	word[n].bool_blank=!word[n].bool_blank;	// ??? ???? ??? ???. 
}
